<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A feature-model formula."><title>Formula in clausy::core::formula - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="clausy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../clausy/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../clausy/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Formula</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.exprs">exprs</a></li><li><a href="#structfield.exprs_inv">exprs_inv</a></li><li><a href="#structfield.new_exprs">new_exprs</a></li><li><a href="#structfield.root_id">root_id</a></li><li><a href="#structfield.var_aux_id">var_aux_id</a></li><li><a href="#structfield.vars">vars</a></li><li><a href="#structfield.vars_inv">vars_inv</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.add_expr">add_expr</a></li><li><a href="#method.add_var">add_var</a></li><li><a href="#method.add_var_aux">add_var_aux</a></li><li><a href="#method.add_var_aux_expr">add_var_aux_expr</a></li><li><a href="#method.add_var_named">add_var_named</a></li><li><a href="#method.assert_canon">assert_canon</a></li><li><a href="#method.assert_valid">assert_valid</a></li><li><a href="#method.canon_visitor">canon_visitor</a></li><li><a href="#method.cnf_dist_visitor">cnf_dist_visitor</a></li><li><a href="#method.cnf_tseitin_visitor">cnf_tseitin_visitor</a></li><li><a href="#method.def_and">def_and</a></li><li><a href="#method.def_or">def_or</a></li><li><a href="#method.expr">expr</a></li><li><a href="#method.flatten_expr">flatten_expr</a></li><li><a href="#method.format_expr">format_expr</a></li><li><a href="#method.get_expr">get_expr</a></li><li><a href="#method.get_root_expr">get_root_expr</a></li><li><a href="#method.get_var_named">get_var_named</a></li><li><a href="#method.inval_expr">inval_expr</a></li><li><a href="#method.negate_exprs">negate_exprs</a></li><li><a href="#method.new">new</a></li><li><a href="#method.nnf_visitor">nnf_visitor</a></li><li><a href="#method.postorder_rev">postorder_rev</a></li><li><a href="#method.preorder_rev">preorder_rev</a></li><li><a href="#method.prepostorder_rev">prepostorder_rev</a></li><li><a href="#method.reset_root_expr">reset_root_expr</a></li><li><a href="#method.set_expr">set_expr</a></li><li><a href="#method.set_root_expr">set_root_expr</a></li><li><a href="#method.simp_expr">simp_expr</a></li><li><a href="#method.sub_exprs">sub_exprs</a></li><li><a href="#method.to_cnf_dist">to_cnf_dist</a></li><li><a href="#method.to_cnf_tseitin">to_cnf_tseitin</a></li><li><a href="#method.to_nnf">to_nnf</a></li><li><a href="#method.var_expr">var_expr</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-Formula%3C'a%3E">Debug</a></li><li><a href="#impl-Display-for-Formula%3C'a%3E">Display</a></li><li><a href="#impl-FormulaParsee%3C'a%3E-for-Formula%3C'a%3E">FormulaParsee&lt;&#x27;a&gt;</a></li><li><a href="#impl-From%3C%26'a+str%3E-for-Formula%3C'a%3E">From&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-From%3C%26Formula%3C'a%3E%3E-for-Clauses%3C'a%3E">From&lt;&amp;Formula&lt;&#x27;a&gt;&gt;</a></li><li><a href="#impl-From%3C(%26'a+String,+T)%3E-for-Formula%3C'a%3E">From&lt;(&amp;&#x27;a String, T)&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Formula%3C'a%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Formula%3C'a%3E">Send</a></li><li><a href="#impl-Sync-for-Formula%3C'a%3E">Sync</a></li><li><a href="#impl-Unpin-for-Formula%3C'a%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Formula%3C'a%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Formula%3C'a%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Formula%3C'a%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Formula%3C'a%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Formula%3C'a%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Formula%3C'a%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToString-for-Formula%3C'a%3E">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Formula%3C'a%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Formula%3C'a%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In clausy::core::formula</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">clausy</a>::<wbr><a href="../index.html">core</a>::<wbr><a href="index.html">formula</a>::<wbr><a class="struct" href="#">Formula</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/clausy/core/formula.rs.html#167-229">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub(crate) struct Formula&lt;'a&gt; {
    pub(crate) exprs: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>&gt;,
    exprs_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.u64.html">u64</a>, <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    pub(crate) vars: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a>&lt;'a&gt;&gt;,
    vars_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;<a class="enum" href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a>&gt;,
    root_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>,
    var_aux_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.u32.html">u32</a>,
    new_exprs: <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A feature-model formula.</p>
<p>We represent a formula by storing its syntax tree; that is, each unique sub-expression that appears in it.
In canonical form, sub-expressions are uniquely stored, so no sub-expression appears twice with distinct identifiers (structural sharing).
This allows for concise representation and facilitates some algorithms (e.g., <a href="struct.Formula.html#method.to_cnf_tseitin" title="method clausy::core::formula::Formula::to_cnf_tseitin">Formula::to_cnf_tseitin</a>).
However, it also comes with the downside that each sub-expression has potentially many parents.
Thus, owners of sub-expressions are not easily trackable (see <a href="struct.Formula.html#structfield.exprs" title="field clausy::core::formula::Formula::exprs">Formula::exprs</a> on garbage collection).
Consequently, we cannot access any parents when mutating sub-expressions, only children.
Due to the structural-sharing, we effectively treat the syntax tree as a directed acyclic graph.
We represent this graph as an adjacency list stored in <a href="struct.Formula.html#structfield.exprs" title="field clausy::core::formula::Formula::exprs">Formula::exprs</a>.
Note that due to performance reasons, structural sharing is not fully guaranteed by all algorithms (including parsers) until calling <a href="struct.Formula.html#method.canon_visitor" title="method clausy::core::formula::Formula::canon_visitor">Formula::canon_visitor</a>.</p>
</div></details><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.exprs" class="structfield small-section-header"><a href="#structfield.exprs" class="anchor field">§</a><code>exprs: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>&gt;</code></span><div class="docblock"><p>Stores all expressions in this formula.</p>
<p>Serves as a fast lookup for an expression, given its identifier.
Expressions are stored in the order of their creation, so new expressions are appended with <a href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html#method.push" title="method alloc::vec::Vec::push">Vec::push</a>.
Also, while algorithms may update expressions in-place, no expression is ever removed.
We refer to all expressions that appear below the root expression as sub-expressions (including the root expression).
By not ever removing any expressions, we keep all non-sub-expressions indefinitely.
This potentially requires a lot of memory, but avoids explicit reference counting or garbage collection.</p>
</div><span id="structfield.exprs_inv" class="structfield small-section-header"><a href="#structfield.exprs_inv" class="anchor field">§</a><code>exprs_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.u64.html">u64</a>, <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;&gt;</code></span><div class="docblock"><p>Maps expressions to their identifiers.</p>
<p>Serves as a fast inverse lookup for the unique identifier of a given sub-expression.
To simplify ownership, we implement this lookup by mapping from the hash of a sub-expression to several identifiers.
By structural sharing, the identifier for a sub-expression should be unique, but we still need a <a href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a> for two reasons:
First, there might be hash collisions, which we address by checking true equality when reading <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
Second, while sub-expressions have a unique identifier, there might be distinct, orphaned expressions that are equal to a given sub-expression.
For example, such a situation arises when <a href="struct.Formula.html#method.set_expr" title="method clausy::core::formula::Formula::set_expr">Formula::set_expr</a> modifies a sub-expression
and the resulting expression is equal (but not identical) to an existing sub-expression.
As an expression cannot easily update its own identifier in the whole syntax tree,
<a href="struct.Formula.html#method.set_expr" title="method clausy::core::formula::Formula::set_expr">Formula::set_expr</a> considers the first identifier in <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a> to be the canonical one (modulo hash collisions).
Whenever <a href="struct.Formula.html#method.set_expr" title="method clausy::core::formula::Formula::set_expr">Formula::set_expr</a> encounters the concerned expression later, it then adapts its identifier to the canonical one.
By this design, <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a> indeed maps any sub-expression (precisely: its hash) to its unique identifier
(precisely: the first identifier whose expression is equal to the given sub-expression).
This information can be used to enforce structural sharing by calling <a href="struct.Formula.html#method.canon_visitor" title="method clausy::core::formula::Formula::canon_visitor">Formula::canon_visitor</a>.</p>
</div><span id="structfield.vars" class="structfield small-section-header"><a href="#structfield.vars" class="anchor field">§</a><code>vars: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a>&lt;'a&gt;&gt;</code></span><div class="docblock"><p>Stores all variables in this formula.</p>
<p>Conceptually, this is analogous to <a href="struct.Formula.html#structfield.exprs" title="field clausy::core::formula::Formula::exprs">Formula::exprs</a>.
However, there is no distinction analogous to sub-expressions and expressions, as variables need not be removed.
Consequently, feature-model slicing (variable forgetting) is currently not supported.
Another difference to <a href="struct.Formula.html#structfield.exprs" title="field clausy::core::formula::Formula::exprs">Formula::exprs</a> is that named variables are not owned by this formula.
Thus, we can borrow references to variable names from the parsed string and avoid cloning them.</p>
</div><span id="structfield.vars_inv" class="structfield small-section-header"><a href="#structfield.vars_inv" class="anchor field">§</a><code>vars_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;<a class="enum" href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a>&gt;</code></span><div class="docblock"><p>Maps variables to their identifiers.</p>
<p>Conceptually, this is analogous to <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
However, the inverse lookup of variables is less complex:
First, this formula does not own the variable names, which avoids the hash collisions discussed for <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
Second, variables and their identifiers are never mutated after creation, so no additional <a href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a> is needed.</p>
</div><span id="structfield.root_id" class="structfield small-section-header"><a href="#structfield.root_id" class="anchor field">§</a><code>root_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></code></span><div class="docblock"><p>Specifies the root expression of this formula.</p>
<p>Serves as an index into <a href="struct.Formula.html#structfield.exprs" title="field clausy::core::formula::Formula::exprs">Formula::exprs</a>.
The corresponding expression is the root of this formula’s syntax tree and thus the starting point for most algorithms.
We consider all expressions below this expression (including itself) to be sub-expressions.
There might be other (non-sub-)expressions that are currently not relevant to this formula.</p>
</div><span id="structfield.var_aux_id" class="structfield small-section-header"><a href="#structfield.var_aux_id" class="anchor field">§</a><code>var_aux_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.u32.html">u32</a></code></span><div class="docblock"><p>Specifies the identifier of the most recently added auxiliary variable.</p>
<p>Ensures that new auxiliary variables (created with <a href="enum.Var.html#variant.Aux" title="variant clausy::core::formula::Var::Aux">Var::Aux</a>) are uniquely identified in the context of this formula.</p>
</div><span id="structfield.new_exprs" class="structfield small-section-header"><a href="#structfield.new_exprs" class="anchor field">§</a><code>new_exprs: <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;&gt;</code></span><div class="docblock"><p>Stores new expressions created by an algorithm but not yet included in the syntax tree.</p>
<p>Used by <a href="struct.Formula.html#method.to_cnf_tseitin" title="method clausy::core::formula::Formula::to_cnf_tseitin">Formula::to_cnf_tseitin</a> for holding on to definitional expressions.</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#238-760">source</a><a href="#impl-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="docblock"><p>Algorithms for constructing, mutating, and analyzing formulas.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#244-254">source</a><h4 class="code-header">pub(crate) fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new, empty formula.</p>
<p>The created formula is initially invalid (see <a href="struct.Formula.html#method.assert_valid" title="method clausy::core::formula::Formula::assert_valid">Formula::assert_valid</a>).
The auxiliary variable with number 0 has no meaningful sign and can therefore not be used.
This simplifies the representation of literals in <a href="../clauses/struct.Clauses.html" title="struct clausy::core::clauses::Clauses">crate::core::clauses::Clauses</a>, which can be negative.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assert_valid" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#262-266">source</a><h4 class="code-header">pub(crate) fn <a href="#method.assert_valid" class="fn">assert_valid</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Panics if this formula is invalid.</p>
<p>A formula is valid if it has at least one variable (added with <a href="struct.Formula.html#method.var_expr" title="method clausy::core::formula::Formula::var_expr">Formula::var_expr</a>) and a root expression (set with <a href="struct.Formula.html#method.set_root_expr" title="method clausy::core::formula::Formula::set_root_expr">Formula::set_root_expr</a>).
In addition, structural sharing must not be violated (see <a href="struct.Formula.html#method.canon_visitor" title="method clausy::core::formula::Formula::canon_visitor">Formula::canon_visitor</a>).
All assertions are optional and therefore not included in <code>cargo build --release</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#273-279">source</a><h4 class="code-header">fn <a href="#method.add_expr" class="fn">add_expr</a>(&amp;mut self, expr: <a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds a new expression to this formula, returning its new identifier.</p>
<p>Appends the given expression to <a href="struct.Formula.html#structfield.exprs" title="field clausy::core::formula::Formula::exprs">Formula::exprs</a> and enables its lookup via <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
Requires that no expression equal to the given expression is already in this formula.
Thus, the created identifier will become the expression’s canonical identifier (see <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#285-292">source</a><h4 class="code-header">fn <a href="#method.get_expr" class="fn">get_expr</a>(&amp;self, expr: &amp;<a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Looks ups the identifier for an expression of this formula.</p>
<p>The canonical identifier for a given expression is the first one that is associated with its hash
and whose expression is also equal to the given expression (see <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#299-302">source</a><h4 class="code-header">pub(crate) fn <a href="#method.expr" class="fn">expr</a>(&amp;mut self, expr: <a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds or looks up an expression of this formula, returning its identifier.</p>
<p>This is the preferred way to obtain an expression’s identifier, as it ensures structural sharing.
That is, the expression is only added to this formula if it does not already exist.
Before we add the expression, we simplify it, which is a cheap operation (in contrast to <a href="struct.Formula.html#method.flatten_expr" title="method clausy::core::formula::Formula::flatten_expr">Formula::flatten_expr</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_var" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#307-313">source</a><h4 class="code-header">fn <a href="#method.add_var" class="fn">add_var</a>(&amp;mut self, var: <a class="enum" href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Adds a new variable to this formula, returning its identifier.</p>
<p>Works analogously to <a href="struct.Formula.html#method.add_expr" title="method clausy::core::formula::Formula::add_expr">Formula::add_expr</a> (see <a href="struct.Formula.html#structfield.vars_inv" title="field clausy::core::formula::Formula::vars_inv">Formula::vars_inv</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_var_named" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#316-318">source</a><h4 class="code-header">fn <a href="#method.add_var_named" class="fn">add_var_named</a>(&amp;mut self, name: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Adds a new named variable to this formula, returning its identifier.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_var_aux" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#321-324">source</a><h4 class="code-header">pub(crate) fn <a href="#method.add_var_aux" class="fn">add_var_aux</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Adds a new auxiliary variable to this formula, returning its identifier.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_var_named" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#329-331">source</a><h4 class="code-header">fn <a href="#method.get_var_named" class="fn">get_var_named</a>(&amp;mut self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a>&gt;</h4></section></summary><div class="docblock"><p>Looks ups the identifier of a named variable in this formula.</p>
<p>Works analogously to <a href="struct.Formula.html#method.get_expr" title="method clausy::core::formula::Formula::get_expr">Formula::get_expr</a> (see <a href="struct.Formula.html#structfield.vars_inv" title="field clausy::core::formula::Formula::vars_inv">Formula::vars_inv</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.var_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#336-341">source</a><h4 class="code-header">pub(crate) fn <a href="#method.var_expr" class="fn">var_expr</a>(&amp;mut self, var: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds or looks up a named variable of this formula, returning its <a href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a> expression’s identifier.</p>
<p>This is the preferred way to obtain a <a href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a> expression’s identifier (see <a href="struct.Formula.html#method.expr" title="method clausy::core::formula::Formula::expr">Formula::expr</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_var_aux_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#344-347">source</a><h4 class="code-header">pub(crate) fn <a href="#method.add_var_aux_expr" class="fn">add_var_aux_expr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds a new auxiliary variable to this formula, returning its <a href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a> expression’s identifier.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_root_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#350-352">source</a><h4 class="code-header">pub(crate) fn <a href="#method.get_root_expr" class="fn">get_root_expr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the root expression of this formula.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_root_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#358-360">source</a><h4 class="code-header">pub(crate) fn <a href="#method.set_root_expr" class="fn">set_root_expr</a>(&amp;mut self, root_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Sets the root expression of this formula.</p>
<p>For a formula to be valid, the root expression has to be set at least once.
It may also be updated subsequently to focus on other expressions of the formula or build more complex expressions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.simp_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#371-383">source</a><h4 class="code-header">fn <a href="#method.simp_expr" class="fn">simp_expr</a>(&amp;mut self, expr: &amp;mut <a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>)</h4></section></summary><div class="docblock"><p>Simplifies an expression in this formula to an equivalent one.</p>
<p>First, we sort the expression’s children, thus equality is up to commutativity.
Second, we remove duplicate children of the expressions, thus equality is up to idempotency.
Third, we identify unary expressions with their operands (i.e., <code>And(x)</code> is simplified to <code>x</code>).
Fourth, we remove double negations (i.e., <code>Not(Not(x))</code> is simplified to <code>x</code>).
Fifth, we remove obvious tautologies and contradictions (i.e., <code>And(a, Not(a))</code> is simplified to <code>Or()</code>).
Because we clone expressions, this function may violate structural sharing (see <a href="struct.Formula.html#method.canon_visitor" title="method clausy::core::formula::Formula::canon_visitor">Formula::canon_visitor</a>).
As this is a cheap and useful operation to make the formula smaller, we already call it in the parsing stage.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#390-396">source</a><h4 class="code-header">fn <a href="#method.flatten_expr" class="fn">flatten_expr</a>(&amp;mut self, expr: &amp;mut <a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>)</h4></section></summary><div class="docblock"><p>Flattens children of an expression into their parent.</p>
<p>Analogously to <a href="struct.Formula.html#method.simp_expr" title="method clausy::core::formula::Formula::simp_expr">Formula::simp_expr</a>, this performs a simplification of an expression.
However, this may create new expressions and is therefore more expensive and not called in the parsing stage.
This is useful to call during a postorder syntax tree traversal to ensure canonical form (see <a href="struct.Formula.html#method.canon_visitor" title="method clausy::core::formula::Formula::canon_visitor">Formula::canon_visitor</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.inval_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#407-412">source</a><h4 class="code-header">fn <a href="#method.inval_expr" class="fn">inval_expr</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Invalidates an expression after it was mutated.</p>
<p>Does so by updating its mapping in <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
One of two cases applies, which can both be handled in the same way:
Either the new expression has never been added before, so structural sharing was not violated.
Thus, we can just append the expression’s identifier as the new canonical identifier for the expression.
In the second case, the expression already exists and already has a canonical identifier.
Still, we can append the identifier anyway, as only the first identifier will be considered.
In terms of correctness, appending the identifier suffices, although we may optimize by cleaning up <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::core::formula::Formula::exprs_inv">Formula::exprs_inv</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#429-446">source</a><h4 class="code-header">fn <a href="#method.set_expr" class="fn">set_expr</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>, expr: <a class="enum" href="enum.Expr.html" title="enum clausy::core::formula::Expr">Expr</a>)</h4></section></summary><div class="docblock"><p>Mutates an expression in this formula.</p>
<p>This function replaces the expression for a given identifier with a new given expression.
It has no effect on leaves in the syntax tree (i.e., variables).
We must take several precautions to preserve structural sharing, as we perform an in-place mutation.
While this function may temporarily violate structural sharing when called for a given expression,
it also makes up for (i.e., “fixes”) said violation when called for every parent of said expression afterwards (see <a href="struct.Formula.html#method.canon_visitor" title="method clausy::core::formula::Formula::canon_visitor">Formula::canon_visitor</a>).
To do so, the function performs three steps:
First, every new child expression is checked for potential duplicates with existing expressions,
which we resolve using the canonical identifier obtained with <a href="struct.Formula.html#method.get_expr" title="method clausy::core::formula::Formula::get_expr">Formula::get_expr</a>.
Second, we replace the old expression with the new expression.
Third, as we might have changed the hash of the expression, we must invalidate it with <a href="struct.Formula.html#method.inval_expr" title="method clausy::core::formula::Formula::inval_expr">Formula::inval_expr</a>.
Because this function cleans up violations of children, it must be called after, not before children have been mutated.
Thus, it does not preserve structural sharing when used in <a href="struct.Formula.html#method.preorder_rev" title="method clausy::core::formula::Formula::preorder_rev">Formula::preorder_rev</a>, only in <a href="struct.Formula.html#method.postorder_rev" title="method clausy::core::formula::Formula::postorder_rev">Formula::postorder_rev</a>.
Besides guaranteeing structural sharing, we perform flattening and simplification on the expression, which usually produces smaller formulas.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reset_root_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#453-455">source</a><h4 class="code-header">fn <a href="#method.reset_root_expr" class="fn">reset_root_expr</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Resets the root expression, if necessary.</p>
<p>If the root expression is mutated with <a href="struct.Formula.html#method.set_expr" title="method clausy::core::formula::Formula::set_expr">Formula::set_expr</a>, structural sharing might be violated.
Because <a href="struct.Formula.html#method.set_expr" title="method clausy::core::formula::Formula::set_expr">Formula::set_expr</a> can only address this issue for children,
we need not explicitly address the only expression that is not a child itself - the root expression.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.negate_exprs" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#460-465">source</a><h4 class="code-header">fn <a href="#method.negate_exprs" class="fn">negate_exprs</a>(&amp;mut self, ids: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns expressions that negate the given expressions.</p>
<p>The returned expression identifiers are either created or looked up (see <a href="struct.Formula.html#method.expr" title="method clausy::core::formula::Formula::expr">Formula::expr</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.format_expr" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#472-497">source</a><h4 class="code-header">fn <a href="#method.format_expr" class="fn">format_expr</a>(&amp;self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.72.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class="docblock"><p>Writes an expression of this formula to a formatter.</p>
<p>Used by <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">fmt::Display</a> to print (parts of) a formula.
Implements a recursive preorder traversal.
For an iterative reversed preorder traversal, see <a href="struct.Formula.html#method.preorder_rev" title="method clausy::core::formula::Formula::preorder_rev">Formula::preorder_rev</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.preorder_rev" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#507-519">source</a><h4 class="code-header">fn <a href="#method.preorder_rev" class="fn">preorder_rev</a>(
    &amp;mut self,
    first_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>,
    visitor: impl <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut Self</a>, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)
)</h4></section></summary><div class="docblock"><p>Visits all sub-expressions of this formula using a reverse preorder traversal.</p>
<p>We assume that the given visitor is idempotent (in terms of formula mutation) and only
performs mutation with the designated methods, such as <a href="struct.Formula.html#method.var_expr" title="method clausy::core::formula::Formula::var_expr">Formula::var_expr</a>, <a href="struct.Formula.html#method.expr" title="method clausy::core::formula::Formula::expr">Formula::expr</a> and <a href="struct.Formula.html#method.set_expr" title="method clausy::core::formula::Formula::set_expr">Formula::set_expr</a>.
The visitor is called at most once per unique sub-expression:
It will not be called several times on the same sub-expression as long (as it does not violate structural sharing).
However, we can also not guarantee it to be called on all sub-expressions - as it might change the very set of sub-expressions.
For improved performance, the traversal is reversed, so children are traversed right-to-left.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.postorder_rev" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#526-546">source</a><h4 class="code-header">fn <a href="#method.postorder_rev" class="fn">postorder_rev</a>(
    &amp;mut self,
    first_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>,
    visitor: impl <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut Self</a>, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)
)</h4></section></summary><div class="docblock"><p>Visits all sub-expressions of this formula using a reverse postorder traversal.</p>
<p>Conceptually, this is similar to <a href="struct.Formula.html#method.preorder_rev" title="method clausy::core::formula::Formula::preorder_rev">Formula::preorder_rev</a>, but sub-expressions are visited bottom-up instead of top-down.
Also, this traversal can be used to ensure structural sharing if the visitor is correctly implemented (see <a href="struct.Formula.html#method.canon_visitor" title="method clausy::core::formula::Formula::canon_visitor">Formula::canon_visitor</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prepostorder_rev" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#553-581">source</a><h4 class="code-header">fn <a href="#method.prepostorder_rev" class="fn">prepostorder_rev</a>(
    &amp;mut self,
    first_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>,
    pre_visitor: impl <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut Self</a>, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>),
    post_visitor: impl <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut Self</a>, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)
)</h4></section></summary><div class="docblock"><p>Visits all sub-expressions of this formula using a combined reverse pre- and postorder traversal.</p>
<p>Can be used to efficiently interleave a preorder and postorder visitor.
Note that each interior expression is visited twice (with the pre- and then the postorder visitor).
However, the leaves (i.e., <a href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a> expressions) are only visited once (with the postorder visitor).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub_exprs" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#586-592">source</a><h4 class="code-header">pub(crate) fn <a href="#method.sub_exprs" class="fn">sub_exprs</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the identifiers of all sub-expressions of this formula.</p>
<p>If in canonical form, each identifier is guaranteed to appear only once.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assert_canon" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#599-603">source</a><h4 class="code-header">fn <a href="#method.assert_canon" class="fn">assert_canon</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Panics if structural sharing is violated in this formula.</p>
<p>That is, we assert that every sub-expression’s identifier is indeed the canonical one.
Does not currently check for commutativity, idempotency, or unary expressions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.canon_visitor" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#613-615">source</a><h4 class="code-header">fn <a href="#method.canon_visitor" class="fn">canon_visitor</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Transforms this formula into canonical form.</p>
<p>In canonical form, several useful guarantees hold:
First, no sub-expression occurs twice in the syntax tree with different identifiers (structural sharing).
Second, equality of sub-expressions is up to commutativity, idempotency, and unary expressions.
Third, no <code>And</code> expression is below an <code>And</code> expression (and analogously for <code>Or</code>).
Fourth, no <code>Not</code> expression is below a <code>Not</code> expression.
To ensure these guarantees, this visitor must be called in a postorder traversal, preorder does not work.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nnf_visitor" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#621-637">source</a><h4 class="code-header">fn <a href="#method.nnf_visitor" class="fn">nnf_visitor</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Transforms this formula into negation normal form by applying De Morgan’s laws.</p>
<p>We do this by traversing the formula top-down, eanwhile, we push negations towards the leaves (i.e., <a href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a> expressions).
Double negations cannot be encountered, as they have already been removed by <a href="struct.Formula.html#method.simp_expr" title="method clausy::core::formula::Formula::simp_expr">Formula::simp_expr</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cnf_dist_visitor" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#644-679">source</a><h4 class="code-header">fn <a href="#method.cnf_dist_visitor" class="fn">cnf_dist_visitor</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Transforms this formula into canonical conjunctive normal form by applying distributivity laws.</p>
<p>We do this by traversing the formula bottom-up and pushing <a href="enum.Expr.html#variant.Or" title="variant clausy::core::formula::Expr::Or">Or</a> expressions below <a href="enum.Expr.html#variant.And" title="variant clausy::core::formula::Expr::And">And</a> expressions via multiplication.
This algorithm has exponential worst-case complexity, but ensures logical equivalence to the original formula.
Assumes that this formula is already in negation normal form.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.def_and" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#685-698">source</a><h4 class="code-header">fn <a href="#method.def_and" class="fn">def_and</a>(&amp;mut self, var_expr_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>, ids: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>]) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a>, <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;)</h4></section></summary><div class="docblock"><p>Defines an <a href="enum.Expr.html#variant.And" title="variant clausy::core::formula::Expr::And">And</a> expression with a new auxiliary variable.</p>
<p>That is, we create a new auxiliary variable and clauses that let it imply all conjuncts and let it be implied by the conjunction.
As an optimization, we do not create a <a href="enum.Var.html" title="enum clausy::core::formula::Var">Var</a> expression for the new variable, as we are replacing an existing expression.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.def_or" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#704-715">source</a><h4 class="code-header">fn <a href="#method.def_or" class="fn">def_or</a>(&amp;mut self, var_expr_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>, ids: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>]) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a>, <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;)</h4></section></summary><div class="docblock"><p>Defines an <a href="enum.Expr.html#variant.Or" title="variant clausy::core::formula::Expr::Or">Or</a> expression with a new auxiliary variable.</p>
<p>That is, we create a new auxiliary variable and clauses that let it imply the disjunction and let it be implied by all disjuncts.
Works analogously to <a href="struct.Formula.html#method.def_and" title="method clausy::core::formula::Formula::def_and">Formula::def_and</a>.</p>
</div></details><section id="method.cnf_tseitin_visitor" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#720-734">source</a><h4 class="code-header">fn <a href="#method.cnf_tseitin_visitor" class="fn">cnf_tseitin_visitor</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)</h4></section><details class="toggle method-toggle" open><summary><section id="method.to_nnf" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#737-740">source</a><h4 class="code-header">pub(crate) fn <a href="#method.to_nnf" class="fn">to_nnf</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Transforms this formula into canonical negation normal form by applying De Morgan’s laws.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_cnf_dist" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#743-746">source</a><h4 class="code-header">pub(crate) fn <a href="#method.to_cnf_dist" class="fn">to_cnf_dist</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Transforms this formula into canonical conjunctive normal form by applying distributivity laws.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_cnf_tseitin" class="method"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#749-759">source</a><h4 class="code-header">pub(crate) fn <a href="#method.to_cnf_tseitin" class="fn">to_cnf_tseitin</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Transforms this formula into canonical conjunctive normal form by TODO</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#166">source</a><a href="#impl-Debug-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#166">source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.72.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#780-784">source</a><a href="#impl-Display-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="docblock"><p>Displays a formula.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../../../src/clausy/core/formula.rs.html#781-783">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.72.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FormulaParsee%3C'a%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../../src/clausy/parser/mod.rs.html#67-71">source</a><a href="#impl-FormulaParsee%3C'a%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="../../parser/trait.FormulaParsee.html" title="trait clausy::parser::FormulaParsee">FormulaParsee</a>&lt;'a&gt; for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="docblock"><p>Parses a feature-model formula file into an existing formula.</p>
</div><div class="impl-items"><section id="method.parse" class="method trait-impl"><a class="srclink rightside" href="../../../src/clausy/parser/mod.rs.html#68-70">source</a><a href="#method.parse" class="anchor">§</a><h4 class="code-header">fn <a href="../../parser/trait.FormulaParsee.html#tymethod.parse" class="fn">parse</a>(&amp;mut self, file: &amp;'a <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, parser: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../../parser/trait.FormulaParser.html" title="trait clausy::parser::FormulaParser">FormulaParser</a>&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26'a+str%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../../src/clausy/parser/model.rs.html#62-69">source</a><a href="#impl-From%3C%26'a+str%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="srclink rightside" href="../../../src/clausy/parser/model.rs.html#63-68">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(file: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Formula%3C'a%3E%3E-for-Clauses%3C'a%3E" class="impl"><a class="srclink rightside" href="../../../src/clausy/core/clauses.rs.html#128-135">source</a><a href="#impl-From%3C%26Formula%3C'a%3E%3E-for-Clauses%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;<a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;&gt; for <a class="struct" href="../clauses/struct.Clauses.html" title="struct clausy::core::clauses::Clauses">Clauses</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="../../../src/clausy/core/clauses.rs.html#129-134">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(formula: &amp;<a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C(%26'a+String,+T)%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../../src/clausy/parser/mod.rs.html#56-64">source</a><a href="#impl-From%3C(%26'a+String,+T)%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;(&amp;'a <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, T)&gt; for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="../../parser/trait.FormulaParser.html" title="trait clausy::parser::FormulaParser">FormulaParser</a>,</span></h3></section></summary><div class="docblock"><p>Creates a feature-model formula from a feature-model formula file and parser.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="srclink rightside" href="../../../src/clausy/parser/mod.rs.html#60-63">source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(file_and_parser: (&amp;'a <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, T)) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Formula%3C'a%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-Send-for-Formula%3C'a%3E" class="impl"><a href="#impl-Send-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-Sync-for-Formula%3C'a%3E" class="impl"><a href="#impl-Sync-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-Unpin-for-Formula%3C'a%3E" class="impl"><a href="#impl-Unpin-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe-for-Formula%3C'a%3E" class="impl"><a href="#impl-UnwindSafe-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::core::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/any.rs.html#201">source</a><a href="#impl-Any-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/any.rs.html#202">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.72.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#725">source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/alloc/string.rs.html#2514">source</a><a href="#impl-ToString-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/alloc/string.rs.html#2520">source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/1.72.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.72.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>