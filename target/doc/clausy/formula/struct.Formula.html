<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A feature-model formula."><title>Formula in clausy::formula - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="clausy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../clausy/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../clausy/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Formula</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.aux_root_id">aux_root_id</a></li><li><a href="#structfield.exprs">exprs</a></li><li><a href="#structfield.exprs_inv">exprs_inv</a></li><li><a href="#structfield.vars">vars</a></li><li><a href="#structfield.vars_inv">vars_inv</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.add_expr">add_expr</a></li><li><a href="#method.add_var">add_var</a></li><li><a href="#method.assert_shared">assert_shared</a></li><li><a href="#method.assert_valid">assert_valid</a></li><li><a href="#method.dedup">dedup</a></li><li><a href="#method.expr">expr</a></li><li><a href="#method.format_expr">format_expr</a></li><li><a href="#method.get_child_exprs">get_child_exprs</a></li><li><a href="#method.get_expr">get_expr</a></li><li><a href="#method.get_root_expr">get_root_expr</a></li><li><a href="#method.get_var">get_var</a></li><li><a href="#method.hash_expr">hash_expr</a></li><li><a href="#method.is_non_aux_and">is_non_aux_and</a></li><li><a href="#method.negate_exprs">negate_exprs</a></li><li><a href="#method.new">new</a></li><li><a href="#method.postorder_rev">postorder_rev</a></li><li><a href="#method.preorder_rev">preorder_rev</a></li><li><a href="#method.print_sub_exprs">print_sub_exprs</a></li><li><a href="#method.reset_aux_root_expr">reset_aux_root_expr</a></li><li><a href="#method.set_child_exprs">set_child_exprs</a></li><li><a href="#method.set_root_expr">set_root_expr</a></li><li><a href="#method.splice_or">splice_or</a></li><li><a href="#method.to_cnf_dist">to_cnf_dist</a></li><li><a href="#method.to_nnf">to_nnf</a></li><li><a href="#method.var">var</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-Formula%3C'a%3E">Debug</a></li><li><a href="#impl-Display-for-Formula%3C'a%3E">Display</a></li><li><a href="#impl-From%3C%26'a+str%3E-for-Formula%3C'a%3E">From&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-From%3CFormula%3C'a%3E%3E-for-CNF%3C'a%3E">From&lt;Formula&lt;&#x27;a&gt;&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Formula%3C'a%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Formula%3C'a%3E">Send</a></li><li><a href="#impl-Sync-for-Formula%3C'a%3E">Sync</a></li><li><a href="#impl-Unpin-for-Formula%3C'a%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Formula%3C'a%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Formula%3C'a%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Formula%3C'a%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Formula%3C'a%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Formula%3C'a%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Formula%3C'a%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToString-for-Formula%3C'a%3E">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Formula%3C'a%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Formula%3C'a%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In clausy::formula</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">clausy</a>::<wbr><a href="index.html">formula</a>::<wbr><a class="struct" href="#">Formula</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/clausy/formula.rs.html#61-116">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Formula&lt;'a&gt; {
    pub(crate) exprs: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="enum.Expr.html" title="enum clausy::formula::Expr">Expr</a>&gt;,
    exprs_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.u64.html">u64</a>, <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    pub(crate) vars: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>&gt;,
    vars_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a>&gt;,
    aux_root_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A feature-model formula.</p>
<p>We represent a formula by storing its syntax tree; that is, each unique sub-expression that appears in it.
As an invariant, sub-expressions are uniquely stored, so no sub-expression can appear twice with distinct identifiers (structural sharing).
This invariant allows for concise representation and facilitates some algorithms (e.g., Tseitin transformation).
However, it also comes with the downside that each sub-expression has potentially many parents.
Thus, owners of sub-expressions are not easily trackable (see <a href="struct.Formula.html#structfield.exprs" title="field clausy::formula::Formula::exprs">Formula::exprs</a> on garbage collection).
Consequently, all algorithms must be implemented in a way that only mutates the children of an expression, not their parent(s).</p>
</div></details><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.exprs" class="structfield small-section-header"><a href="#structfield.exprs" class="anchor field">§</a><code>exprs: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="enum.Expr.html" title="enum clausy::formula::Expr">Expr</a>&gt;</code></span><div class="docblock"><p>Stores all expressions in this formula.</p>
<p>Serves as a fast lookup for an expression, given its identifier.
Expressions are stored in the order of their creation, so new expressions are appended with <a href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html#method.push" title="method alloc::vec::Vec::push">Vec::push</a>.
Also, while some algorithms may update expressions in-place, no expression is ever removed.
We refer to all expressions that appear below the auxiliary root expression as sub-expressions.
By not ever removing any expressions, we keep all non-sub-expressions indefinitely.
This potentially requires a lot of memory, but avoids explicit reference counting or garbage collection.</p>
</div><span id="structfield.exprs_inv" class="structfield small-section-header"><a href="#structfield.exprs_inv" class="anchor field">§</a><code>exprs_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.u64.html">u64</a>, <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;&gt;</code></span><div class="docblock"><p>Maps expressions to their identifiers.</p>
<p>Serves as a fast inverse lookup for the unique identifier of a given sub-expression.
To simplify ownership, we implement this lookup by mapping from the hash of a sub-expression to several identifiers.
By structural sharing, the identifier for a sub-expression should be unique, but we still need a <a href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a> for two reasons:
First, there might be hash collisions, which we address by checking true equality when reading <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
Second, while sub-expressions have a unique identifier, there might be distinct, orphaned expressions that are equal to a given sub-expression.
For example, such a situation arises when <a href="struct.Formula.html#method.set_child_exprs" title="method clausy::formula::Formula::set_child_exprs">Formula::set_child_exprs</a> modifies its expression’s children
and the resulting expression is equal (but not identical) to an existing sub-expression.
As an expression cannot easily change its own identifier (similar to how a variable cannot change its own type),
<a href="struct.Formula.html#method.set_child_exprs" title="method clausy::formula::Formula::set_child_exprs">Formula::set_child_exprs</a> considers the first identifier in <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a> to be the canonical one (modulo hash collisions).
Whenever <a href="struct.Formula.html#method.set_child_exprs" title="method clausy::formula::Formula::set_child_exprs">Formula::set_child_exprs</a> encounters the concerned expression, it then adapts its identifier to the canonical one.
By this design, <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a> indeed maps any sub-expression (precisely: its hash) to its unique identifier
(precisely: the first identifier whose expression is equal to the given sub-expression).
Any algorithms that mutate this formula should take this into account to preserve structural sharing as an invariant.</p>
</div><span id="structfield.vars" class="structfield small-section-header"><a href="#structfield.vars" class="anchor field">§</a><code>vars: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>&gt;</code></span><div class="docblock"><p>Stores all variables in this formula.</p>
<p>Conceptually, this is analogous to <a href="struct.Formula.html#structfield.exprs" title="field clausy::formula::Formula::exprs">Formula::exprs</a>.
However, there is no distinction analogous to sub-expressions and expressions, as variables need not be removed.
Consequently, feature-model slicing (variable forgetting) is currently not supported.
Another difference to <a href="struct.Formula.html#structfield.exprs" title="field clausy::formula::Formula::exprs">Formula::exprs</a> is that variables (which are simply names) are not owned by this formula.
Thus, we can borrow references to variable names from the parsed string and avoid cloning them.</p>
</div><span id="structfield.vars_inv" class="structfield small-section-header"><a href="#structfield.vars_inv" class="anchor field">§</a><code>vars_inv: <a class="struct" href="https://doc.rust-lang.org/1.72.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>, <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.i32.html">i32</a>&gt;</code></span><div class="docblock"><p>Maps variables to their identifiers.</p>
<p>Conceptually, this is analogous to <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
However, the inverse lookup of variables is simpler:
First, this formula does not own the variables, which avoids the hash collisions discussed for <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
Second, variables and their identifiers are never mutated after creation, so no additional <a href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a> is needed.</p>
</div><span id="structfield.aux_root_id" class="structfield small-section-header"><a href="#structfield.aux_root_id" class="anchor field">§</a><code>aux_root_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></code></span><div class="docblock"><p>Specifies the auxiliary root expression of this formula.</p>
<p>Serves as an index into <a href="struct.Formula.html#structfield.exprs" title="field clausy::formula::Formula::exprs">Formula::exprs</a>.
The corresponding expression is the auxiliary root of this formula’s syntax tree and thus the starting point for most algorithms.
We consider all expressions below this expression (including itself) to be sub-expressions.
There might be other (non-sub-)expressions that are currently not relevant to this formula.
Note that <a href="struct.Formula.html#method.get_root_expr" title="method clausy::formula::Formula::get_root_expr">Formula::get_root_expr</a> and <a href="struct.Formula.html#method.set_root_expr" title="method clausy::formula::Formula::set_root_expr">Formula::set_root_expr</a> do not store the user-supplied root expression here,
but an auxiliary <a href="enum.Expr.html#variant.And" title="variant clausy::formula::Expr::And">And</a> expression that has the root expression as its single child.
This allows algorithms to freely mutate the root expression if necessary (see <a href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a> on mutating children).</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#125-547">source</a><a href="#impl-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="docblock"><p>Algorithms for constructing, mutating, and analyzing formulas.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#131-139">source</a><h4 class="code-header">pub(crate) fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new, empty formula.</p>
<p>The created formula is initially invalid (see <a href="struct.Formula.html#method.assert_valid" title="method clausy::formula::Formula::assert_valid">Formula::assert_valid</a>).
The variable with empty name and identifier 0 has no meaningful sign and can therefore not be used.
This simplifies the representation of literals in <a href="../cnf/struct.CNF.html" title="struct clausy::cnf::CNF">crate::cnf::CNF</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assert_valid" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#144-149">source</a><h4 class="code-header">fn <a href="#method.assert_valid" class="fn">assert_valid</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Panics if this formula is invalid.</p>
<p>A formula is valid if it has at least one variable (added with <a href="struct.Formula.html#method.var" title="method clausy::formula::Formula::var">Formula::var</a>) and a root expression (set with <a href="struct.Formula.html#method.set_root_expr" title="method clausy::formula::Formula::set_root_expr">Formula::set_root_expr</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hash_expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#154-158">source</a><h4 class="code-header">fn <a href="#method.hash_expr" class="fn">hash_expr</a>(expr: &amp;<a class="enum" href="enum.Expr.html" title="enum clausy::formula::Expr">Expr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Computes the hash of an expression.</p>
<p>Used to look up an expression’s identifier in <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#165-171">source</a><h4 class="code-header">fn <a href="#method.add_expr" class="fn">add_expr</a>(&amp;mut self, expr: <a class="enum" href="enum.Expr.html" title="enum clausy::formula::Expr">Expr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds a new expression to this formula, returning its new identifier.</p>
<p>Appends the given expression to <a href="struct.Formula.html#structfield.exprs" title="field clausy::formula::Formula::exprs">Formula::exprs</a> and enables its lookup via <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
Requires that no expression equal to the given expression is already in this formula.
Thus, the created identifier will become the expression’s canonical identifier (see <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#177-185">source</a><h4 class="code-header">fn <a href="#method.get_expr" class="fn">get_expr</a>(&amp;self, expr: &amp;<a class="enum" href="enum.Expr.html" title="enum clausy::formula::Expr">Expr</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Looks ups the identifier for an expression of this formula.</p>
<p>The canonical identifier for a given expression is the first one that is associated with its hash
and whose expression is also equal to the given expression (see <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#191-193">source</a><h4 class="code-header">pub(crate) fn <a href="#method.expr" class="fn">expr</a>(&amp;mut self, expr: <a class="enum" href="enum.Expr.html" title="enum clausy::formula::Expr">Expr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds or looks up an expression of this formula, returning its identifier.</p>
<p>This is the preferred way to obtain an expression’s identifier, as it ensures structural sharing.
That is, the expression is only added to this formula if it does not already exist.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_var" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#200-206">source</a><h4 class="code-header">fn <a href="#method.add_var" class="fn">add_var</a>(&amp;mut self, var: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds a new variable to this formula, returning the identifier of its <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expression.</p>
<p>Works analogously to <a href="struct.Formula.html#method.add_expr" title="method clausy::formula::Formula::add_expr">Formula::add_expr</a> (see <a href="struct.Formula.html#structfield.vars_inv" title="field clausy::formula::Formula::vars_inv">Formula::vars_inv</a>).
However, it does not return the variable’s identifier, but its <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expression’s identifier.
This is usually more convenient.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_var" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#212-214">source</a><h4 class="code-header">fn <a href="#method.get_var" class="fn">get_var</a>(&amp;mut self, var: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Looks ups the identifier for the <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expression of a variable in this formula.</p>
<p>Works analogously to <a href="struct.Formula.html#method.get_expr" title="method clausy::formula::Formula::get_expr">Formula::get_expr</a> (see <a href="struct.Formula.html#structfield.vars_inv" title="field clausy::formula::Formula::vars_inv">Formula::vars_inv</a>).
As for <a href="struct.Formula.html#method.add_var" title="method clausy::formula::Formula::add_var">Formula::add_var</a>, it is usually more convenient to return the <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expression’s identifier.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.var" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#219-221">source</a><h4 class="code-header">pub(crate) fn <a href="#method.var" class="fn">var</a>(&amp;mut self, var: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Adds or looks up a variable of this formula, returning its <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expression’s identifier.</p>
<p>This is the preferred way to obtain a <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expression’s identifier (see <a href="struct.Formula.html#method.expr" title="method clausy::formula::Formula::expr">Formula::expr</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_root_expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#226-234">source</a><h4 class="code-header">pub(crate) fn <a href="#method.get_root_expr" class="fn">get_root_expr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the root expression of this formula.</p>
<p>That is, we return the only child of the auxiliary root expression (see <a href="struct.Formula.html#structfield.aux_root_id" title="field clausy::formula::Formula::aux_root_id">Formula::aux_root_id</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_root_expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#241-243">source</a><h4 class="code-header">pub(crate) fn <a href="#method.set_root_expr" class="fn">set_root_expr</a>(&amp;mut self, root_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Sets the root expression of this formula.</p>
<p>That is, we update this formula’s auxiliary root expression with the given expression (see <a href="struct.Formula.html#structfield.aux_root_id" title="field clausy::formula::Formula::aux_root_id">Formula::aux_root_id</a>).
For a formula to be valid, the root expression has to be set at least once.
It may also be updated subsequently to focus on other expressions of the formula.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_child_exprs" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#249-255">source</a><h4 class="code-header">fn <a href="#method.get_child_exprs" class="fn">get_child_exprs</a>&lt;'b&gt;(expr: &amp;'b <a class="enum" href="enum.Expr.html" title="enum clausy::formula::Expr">Expr</a>) -&gt; &amp;'b [<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>]</h4></section></summary><div class="docblock"><p>Returns the identifiers of the children of an expression.</p>
<p>We return nothing for <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expressions, which have no expression identifiers as children (only a variable identifier).
As <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expressions are leaves of a formula’s syntax tree, this function is useful for traversing that tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_child_exprs" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#272-285">source</a><h4 class="code-header">fn <a href="#method.set_child_exprs" class="fn">set_child_exprs</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>, ids: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;)</h4></section></summary><div class="docblock"><p>Sets the children of an expression in this formula.</p>
<p>This function must take several precautions to preserve structural sharing, as it performs in-place mutations.
While this function may temporarily violate structural sharing when called for a given expression,
it also makes up for said violation when called for any parent of said expression.
To do this, the function performs three steps:
First, every new child expression is checked for potential duplicates with existing expressions,
which we resolve using the canonical identifier obtained with <a href="struct.Formula.html#method.get_expr" title="method clausy::formula::Formula::get_expr">Formula::get_expr</a>.
Second, we replace the old children with the new children.
Third, as we might have changed the hash of the expression, we must update its mapping in <a href="struct.Formula.html#structfield.exprs_inv" title="field clausy::formula::Formula::exprs_inv">Formula::exprs_inv</a>.
One of two cases applies, which can both be handled in the same way:
Either the new expression has never been added before, so structural sharing was not violated.
Thus, we can just push the expression’s identifier as the new canonical identifier for the expression.
In the second case, the expression already exists and already has a canonical identifier.
Still, we can push the identifier anyway, as only the first identifier will be considered.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reset_aux_root_expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#292-294">source</a><h4 class="code-header">fn <a href="#method.reset_aux_root_expr" class="fn">reset_aux_root_expr</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Resets the auxiliary root expression, if necessary.</p>
<p>If the auxiliary root expression is mutated with <a href="struct.Formula.html#method.set_child_exprs" title="method clausy::formula::Formula::set_child_exprs">Formula::set_child_exprs</a>, structural sharing might be violated.
Because <a href="struct.Formula.html#method.set_child_exprs" title="method clausy::formula::Formula::set_child_exprs">Formula::set_child_exprs</a> can only address this issue for children,
we need not explicitly address the only expression that is not a child itself - the auxiliary root expression.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.negate_exprs" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#299-304">source</a><h4 class="code-header">fn <a href="#method.negate_exprs" class="fn">negate_exprs</a>(&amp;mut self, ids: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns expressions that negate the given expressions.</p>
<p>The returned expression identifiers are either created or looked up (see <a href="struct.Formula.html#method.expr" title="method clausy::formula::Formula::expr">Formula::expr</a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.format_expr" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#311-331">source</a><h4 class="code-header">fn <a href="#method.format_expr" class="fn">format_expr</a>(&amp;self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.72.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class="docblock"><p>Writes an expression of this formula to a formatter.</p>
<p>Used by <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">fmt::Display</a> to print (parts of) a formula.
Implements a recursive preorder traversal.
For an iterative reversed preorder traversal, see <a href="struct.Formula.html#method.preorder_rev" title="method clausy::formula::Formula::preorder_rev">Formula::preorder_rev</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_non_aux_and" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#334-340">source</a><h4 class="code-header">fn <a href="#method.is_non_aux_and" class="fn">is_non_aux_and</a>(&amp;self, id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p><code>TODO</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splice_or" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#343-352">source</a><h4 class="code-header">fn <a href="#method.splice_or" class="fn">splice_or</a>(&amp;self, clause_id: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>, new_clause: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;)</h4></section></summary><div class="docblock"><p><code>TODO</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dedup" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#355-360">source</a><h4 class="code-header">fn <a href="#method.dedup" class="fn">dedup</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p><code>TODO</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.preorder_rev" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#370-383">source</a><h4 class="code-header">fn <a href="#method.preorder_rev" class="fn">preorder_rev</a>(&amp;mut self, visitor: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.fn.html">fn</a>(_: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut Self</a>, _: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>))</h4></section></summary><div class="docblock"><p>Visits all sub-expressions of this formula using a reverse preorder traversal.</p>
<p>To preserve structural sharing, we assume that the given visitor is idempotent and only performs mutation
with the designated methods, such as <a href="struct.Formula.html#method.var" title="method clausy::formula::Formula::var">Formula::var</a>, <a href="struct.Formula.html#method.expr" title="method clausy::formula::Formula::expr">Formula::expr</a> and <a href="struct.Formula.html#method.set_child_exprs" title="method clausy::formula::Formula::set_child_exprs">Formula::set_child_exprs</a>.
The visitor is called at most once per unique sub-expression:
It will not be called several times on the same sub-expression - this leverages structural sharing.
However, we can also not guarantee it to be called on all sub-expressions - as it might change the set of sub-expressions.
For improved performance, the traversal is reversed, so children are traversed right-to-left.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.postorder_rev" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#388-409">source</a><h4 class="code-header">fn <a href="#method.postorder_rev" class="fn">postorder_rev</a>(&amp;mut self, visitor: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.fn.html">fn</a>(_: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut Self</a>, _: <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.usize.html">usize</a>))</h4></section></summary><div class="docblock"><p>Visits all sub-expressions of this formula using a reverse postorder traversal.</p>
<p>Conceptually, this is similar to <a href="struct.Formula.html#method.preorder_rev" title="method clausy::formula::Formula::preorder_rev">Formula::preorder_rev</a>, but sub-expressions are visited bottom-up instead of top-down.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.print_sub_exprs" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#412-414">source</a><h4 class="code-header">pub fn <a href="#method.print_sub_exprs" class="fn">print_sub_exprs</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Prints all sub-expression of this formula.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assert_shared" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#419-423">source</a><h4 class="code-header">pub fn <a href="#method.assert_shared" class="fn">assert_shared</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Panics if structural sharing is violated in this formula.</p>
<p>That is, we assert that every sub-expression’s identifier is indeed the canonical one.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_nnf" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#429-460">source</a><h4 class="code-header">pub fn <a href="#method.to_nnf" class="fn">to_nnf</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Transforms this formula into negation normal form by applying De Morgan’s laws.</p>
<p>We do this by traversing the formula top-down and pushing negations towards the leaves (i.e., <a href="enum.Expr.html#variant.Var" title="variant clausy::formula::Expr::Var">Var</a> expressions).
<code>TODO</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_cnf_dist" class="method"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#469-546">source</a><h4 class="code-header">pub fn <a href="#method.to_cnf_dist" class="fn">to_cnf_dist</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Transforms this formula into conjunctive normal form by applying distributivity laws.</p>
<p>We do this by traversing the formula bottom-up and pushing <a href="enum.Expr.html#variant.Or" title="variant clausy::formula::Expr::Or">Or</a> expressions below <a href="enum.Expr.html#variant.And" title="variant clausy::formula::Expr::And">And</a> expressions via multiplication.
This algorithm has exponential worst-case complexity, but ensures logical equivalence to the original formula.
<code>TODO</code>
<code>TODO</code> refactor code
<code>TODO</code> is this idempotent?</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#60">source</a><a href="#impl-Debug-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#60">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.72.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#558-562">source</a><a href="#impl-Display-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="docblock"><p>Displays a formula.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="srclink rightside" href="../../src/clausy/formula.rs.html#559-561">source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.72.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26'a+str%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/clausy/parser.rs.html#37-58">source</a><a href="#impl-From%3C%26'a+str%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="srclink rightside" href="../../src/clausy/parser.rs.html#38-57">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(model: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.str.html">str</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CFormula%3C'a%3E%3E-for-CNF%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/clausy/cnf.rs.html#74-81">source</a><a href="#impl-From%3CFormula%3C'a%3E%3E-for-CNF%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;&gt; for <a class="struct" href="../cnf/struct.CNF.html" title="struct clausy::cnf::CNF">CNF</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="../../src/clausy/cnf.rs.html#75-80">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(formula: <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Formula%3C'a%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-Send-for-Formula%3C'a%3E" class="impl"><a href="#impl-Send-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-Sync-for-Formula%3C'a%3E" class="impl"><a href="#impl-Sync-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-Unpin-for-Formula%3C'a%3E" class="impl"><a href="#impl-Unpin-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe-for-Formula%3C'a%3E" class="impl"><a href="#impl-UnwindSafe-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Formula.html" title="struct clausy::formula::Formula">Formula</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/any.rs.html#201">source</a><a href="#impl-Any-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/any.rs.html#202">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.72.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.72.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#725">source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/alloc/string.rs.html#2514">source</a><a href="#impl-ToString-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.72.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/alloc/string.rs.html#2520">source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/1.72.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.72.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Formula%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-Formula%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.0/src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>